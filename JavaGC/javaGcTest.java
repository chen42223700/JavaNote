
public class javaGcTest {
	
	public static void main(String[] args) {
		/*
		 * system.gc()方法
		 * 只是一个请求（建议）
		 * JVM接收这个消息后，并不是立即做垃圾回收
		 * 而是对几个垃圾回收算法做了甲加权
		 * 使垃圾回收操作容易发生，或提早发生，或回收较多
		 */
		
		new javaGcTest();
		System.gc();
		System.runFinalization();
		
		/*
		 * 触发GC的条件：
		 * 1.当应用程序空闲时，即没有应用线程在运行中时，GC会被调用
		 * 应为GC在优先级最低的线程中进行，所以当应用忙时，GC线程就不会被调用
		 * 但是!!!!,以下条件除外
		 * 
		 * 2，Java堆内存不足时,GC会被调用。当应用线程在运行时，当此时内存空间
		 * 不足，JVM就会强制调用GC；当GC一次后任不满足内存的分配要求，JVM会在
		 * 进行两次GC做进一步尝试，,若任无法满足要求，JVM将报“out of memory”
		 * 的错误，Java应用将停止
		 * 
		 * 由于是否进行GC是JVM根据系统环境决定的，而系统环境在不断变化当中，所以
		 * 注GC的运行具有不确定性，无法预计它何时必然出现
		 */
		
		/*
		 *减少GC开销的措施
		 *由于GC的机制，GC的运行会直接影响系统环境的 变化，从而运行GC的触发。
		 *若不针对GC的特点进行设计和编码，就会出现内存驻留等一系列负面影响。
		 *为了尽可能减少垃圾和减少GC过程中的开，我们可以采取以下措施：
		 *
		 *1，不要显示调用System.gc()
		 *2,尽量减少零食对象的使用
		 *3，对象不用时最后显式置为null（有利于GV收集器的垃圾判定，提高了GC效率）
		 *4，尽量使用StringBuffer，而不是String来累加字符串：String拼接会产生多个垃圾对象，而StringBuffer用了字符串缓冲区
		 *5，能用基本类型int,long 就不要用Integer, Long对象因为Integer, Long等更加占内存
		 *6，尽量少使用静态变量：静态变量相当于全局变量，不会被GC回收，会一直占用内存
		 *7，分散对性爱那个创建或删除的时间：
		 *	第七点的解释：
		 *	集中在短时间呗大量穿件新对象，特别是大对象，会导致突然需要大量内存，
		 *	JVM在面临这种情况只能进行主GC，以回收内存或整合内存碎片，从而增加
		 *	主GC的频率。让他集中删除对象，则会大量产生垃圾对象，空闲空间减少，导致
		 *	主GC调用概率变大
		 */
	}
	
	private void testFinalize() throws Throwable{
		// finalize()方法
		/*
		 * 在JVM垃圾回收器收集一个对象之前，一般要求程序
		 * 调用适当的方法释放资源，但是在没有明确释放资源的
		 * 情况下，java提供了缺省机制来终止该对象释放资源
		 * 这就是finalize（）
		 * 
		 * 其原型是：
		 * pritected void finalize() throws Throwable{}
		 * 在finalize方法返回之后，对象消失，垃圾收集开始执行。
		 * 注：throws Throwable 表示他可以抛出任何类型的异常
		 * 
		 * 之所以要使用finalize（）是存在看垃圾回收器不做处理的特殊情况。
		 * 假定你的对象（并非使用new方法）获得了一块“特殊”的内存区域，由于
		 * 垃圾回收器只知道那些显示的经由new分配分配的内存空间，所以他不知道
		 * 该如何释放这块特殊的内存区域，那么这个时候java允许在类中定义一个
		 * 有finalize（）方法来释放该内存
		 * 
		 * 特殊的区域例如：
		 * 1）：由于在分配内存的时候可能采用了类似C语言的做法，而非JAVA通常new的做法。
		 * 这种情况主要发生在native method中，比如native method调用了
		 * C/C++方法malloc（）函数系列来分配存储空间。但是除非调用free（）函数
		 * 否则这些内存空间将不会释放，那么这个时候就可能造成内存泄露。但是由于free（）
		 * 方法是在C/C++中的函数，所以finalize（）中可以用本地方法来调用它。以释放
		 * 这些特殊的内存空间，
		 * 2）：打开某文件资源，这些资源不属于垃圾回收器的回收范围
		 */
		
		try {
			
		} catch (Throwable t) {
			/*
			 *  Throwable也是可以catch的
			 *  
			 *  Throwable：所有以实现的接口：Serializable
			 *  直接已知的子类:
			 *  Error Exception
			 *  
			 *  Throwable 类是Java语言中所有错误或异常的超类。
			 *  是有当对象是此类（或其子类之一）的示例时。才能通过Java
			 *  虚拟机或Java throw语句抛出。
			 *  类似的，只有此类或其子类之一才可以Catch子句中参数类型
			 */
			
		}

	}
	

}
